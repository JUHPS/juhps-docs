{"./":{"url":"./","title":"首页","keywords":"","body":" High Performance Web Server C++高性能高并发服务器框架 LICENSE 本项目的所有代码均使用基于 GNU General Public License v3.0 开源协议开源，并附加下列条款。部分衍生项目采用 MIT License 开源，以目标仓库内的 LICENSE 文件与 README 说明为准 "},"getStarted/":{"url":"getStarted/","title":"开始部署","keywords":"","body":""},"getStarted/common/Prepare.html":{"url":"getStarted/common/Prepare.html","title":"准备工作","keywords":"","body":""},"getStarted/common/StartJUHPS.html":{"url":"getStarted/common/StartJUHPS.html","title":"启动系统","keywords":"","body":""},"server/":{"url":"server/","title":"服务器","keywords":"","body":" 日志模块 线程模块 \\ 配置模块 协程模块 \\ "},"server/Logger/":{"url":"server/Logger/","title":"日志模块","keywords":"","body":"日志模块 用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名/行号，时间戳，线程/协程号，模块名称，日志级别等额外信息，甚至在打印致命的日志时，还应该附加程序的栈回溯信息，以便于分析和排查问题。 1. LogLevel 日志级别 参考log4cpp的设计： enum Level { UNKNOW = 0, DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4, FATAL = 5 }; 2. LogEvent 日志事件 用于记录日志现场，比如该日志的级别，文件名/行号，日志消息，线程/协程号，所属日志器名称等。 3. LogEventWrap 日志事件包装类 将日志事件和日志器包装到一起。因为一条日志只会在一个日志器上进行输出。将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。另外，LogEventWrap还负责在构建时指定日志事件和日志器，在析构时调用日志器的log方法将日志事件进行输出。 4. Logger 日志器 一个Logger包含多个LogAppender和一个日志级别，提供log方法，传入日志事件，判断该日志事件的级别高于日志器本身的级别之后调用LogAppender将日志进行输出，否则该日志被抛弃。 5. LogAppender 日志输出目标 用于将一个日志事件输出到对应的输出地。该类内部包含一个LogFormatter成员和一个log方法，日志事件先经过LogFormatter格式化后再输出到对应的输出地。从这个类可以派生出不同的Appender类型，比如StdoutLogAppender和FileLogAppender，分别表示输出到终端和文件。 6. LogFormatter 日志格式器 与log4cpp的PatternLayout对应，用于格式化一个日志事件。该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。 7. LogManager 日志器管理类 单例模式的设计，用于统一管理所有的日志器，提供日志器的创建与获取方法。LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。 8. Usage 采用宏定义方式 #define JUJIMEIZUO_LOG_DEBUG(logger) JUJIMEIZUO_LOG_LEVEL(logger, jujimeizuo::LogLevel::DEBUG) #define JUJIMEIZUO_LOG_FMT_DEBUG(logger, fmt, ...) JUJIMEIZUO_LOG_FMT_LEVEL(logger, jujimeizuo::LogLevel::DEBUG, fmt, __VA_ARGS__) eg: jujimeizuo::Logger::ptr g_logger = JUJIMEIZUO_LOG_ROOT(); JUJIMEIZUO_LOG_INFO(g_logger) 这里要实现通过g_logger打印一条INFO级别的消息。那么，首先判断INFO级别是否高于g_logger本身的日志级别（这里的设计与原版sylar相反，数字越小，优先级越高），如果不高于，那if语句执行不到，这条日志也不会打印，否则，临时构造一个LogEventWrap对象，传入日志器g_logger，以及现场构造的日志事件。通过LogEventWrap的getLogEvent()方法拿到日志事件，再用日志事件的流式日志消息成员输出日志消息。由于LogEventWrap是在if语句内部构建的，一旦if语句执行结束，LogEventWrap对象就会析构，日志事件也就会被g_logger进行输出。 9. 总结 日志模块的工作流程： 初始化LogFormatter，LogAppender, Logger。 通过宏定义提供流式风格和格式化风格的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，并且将日志事件和日志器Logger包装到一起，生成一个LogEventWrap对象。 日志接口执行结束后，LogEventWrap对象析构，在析构函数里调用Logger的log方法将日志事件进行输出。 "},"server/Config/":{"url":"server/Config/","title":"配置模块","keywords":"","body":"配置模块 用于定义/声明配置项，并且从配置文件中加载用户配置，体现约定大于配置的思想，配置文件采用yml，并用yaml-cpp进行解析，用片特化的方式实现数据类型的序列化和反序列，并用回调函数的机制使其生效。 参考谷歌开源的基于命令行的C++配置库：gflags 1. ConfigVarBase 配置项基类 每个配置项都包括name和description，以及toString()和fromString()两个纯虚函数，用于和YAML字符串进行相互转换。但并不包括配置项类型和值，由继承类实现。 不区分大小写，全部用transform()转成小写进行配置。 2. ConfigVar 配置参数类（继承ConfigVarBase） 2.1 定义成模版类 template , class ToStr = LexicalCast > T为配置项的类型，FromStr()和ToStr()用于YAML字符串的转换，并根据不同的T实现不同的片特化。 2.2 支持变更配置 setValue/getValue方法用于获取/更新配置值（更新配置时会一并触发全部的配置变更回调函数）\\ addListener/delListener方法用于添加或删除配置变更回调函数。 2. Config 配置管理类 负责托管ConfigVar对象。 所有成员都为static，保证全局只有一个实例。 2.1 Lookup 用于根据配置名称查询配置项。 如果调用Lookup查询时同时提供了默认值和配置项的描述信息，那么在未找到对应的配置时，会自动创建一个对应的配置项，这样就保证了配置模块定义即可用的特性。 2.2 LoadFromYaml 从YAML对象加载配置。 3. yaml-cpp 项目的配置文件采用yml，并用yaml-cpp库进行解析。 对于每种类型的配置，在对应的ConfigVar模版类实例化时都要提供FromStr和ToStr两个仿函数，用于实现该类型和YAML字符串的相互转换。 对于每种数据类型，包括自定义数据类型，都需要片特化。从一个基本类型的转换类开始，特化出其他类型的转换类。 template class LexicalCast { public: /** * @brief 类型转换 * @param[in] v 源类型值 * @return 返回v转换后的目标类型 * @exception 当类型不可转换时抛出异常 */ T operator()(const F& v) { return boost::lexical_cast(v); } }; 实现了int、vector、set、map等类型，根据这些类型的搭配，还实现其他复杂类型，例如vector、set等等。 4. Usage YAML::Node root = YAML::LoadFile(\"url/*.yml\"); jujimeizuo::Config::LoadFromYaml(root); 4.1 unordered_map做配置 jujimeizuo::ConfigVar >::ptr g_str_int_unordered_map_value_config = jujimeizuo::Config::Lookup(\"system.str_int_unordered_map\", std::unordered_map{{\"k\", 2}}, \"system str int unordered_map\"); 2022-09-01 00:03:24 4294967295 0 [INFO] [root] /Users/fengzetao/Desktop/WebServer/tests/test_config.cc:142 after str_int_unordered_map: {k2 - 20} 5. 总结 采用约定由于配置的思想。定义即可使用。不需要单独去解析。支持变更通知功能。使用YAML文件做为配置内容。支持级别格式的数据类型，支持STL容器(vector,list,set,map等等),支持自定义类型的支持（需要实现序列化和反序列化方法)。 通过配置系统对日志进行配置需要对日志里的类型进行片特化处理，这样在处理序列化与反序列化的时候才能识别yml文件中的log配置。具体在LogDefine和LogAppenderDefine。 "},"server/Thread/":{"url":"server/Thread/","title":"线程模块","keywords":"","body":"线程模块 提供线程类和线程同步类，基于pthread线程库实现。 1. 线程类 1.1 Thread 构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用std::bind进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。 线程类不提供默认复制、拷贝构造与左值构造，所以将三个默认函数删除掉。 线程类提供五个属性: m_id为pid_t类型，为全局线程id，可以用syscall(SYS_gettid)获取。 m_thread是pthread_t类型，在当前进程中唯一标识线程，可以用pthread_self()函数获取。 m_cb是function类型的属性，是当前线程最终调用的函数。 m_name是当前线程名称可以用于日志输出，调试等等。 m_semaphere是信号量，保护临界资源。 class Thread { public: typedef std::shared_ptr ptr; Thread(std::function cb, const std::string& name); ~Thread(); pid_t getId() const { return m_id; } const std::string& getName() const { return m_name; } void join(); static Thread* GetThis(); static const std::string& GetName(); static void SetName(const std::string& name); private: Thread(const Thread&) = delete; Thread(const Thread&&) = delete; Thread& operator=(const Thread&) = delete; static void* run(void* arg); private: pid_t m_id = -1; pthread_t m_thread = 0; std::function m_cb; std::string m_name; Semaphere m_semaphere; }; Thread类中提供三个静态方法，用于获取当前t_thread和t_thread_name。 Thread::GetThis()、Thread::GetName()、Thread::run()在pthread_create()之前注册，在run()中会完成对两个静态属性的初始化。 pthread_setname_np(pthread_self(), thread->m_name.substr(0, 15).c_str())能够完成在操作系统设置线程名称的任务。 m_semaphore.wait()，在run()中调用真正线程函数之前调用thread->m_semaphore.notify()。是为了保证在完成线程类的构造函数之前，线程已经开始执行了，不然在构造完成之后，线程可能还没开始执行，在离开作用域时会执行析构函数，造成线程还没开始就被pthread_detach()了。 static thread_local Thread* t_thread = nullptr; static thread_local std::string t_thread_name = \"UNKNOW\"; Thread* Thread::GetThis() { return t_thread; } const std::string& Thread::GetName() { return t_thread_name; } void Thread::SetName(const std::string& name) { if (t_thread) { t_thread -> m_name = name; } else { t_thread_name = name; } } void* Thread::run(void* arg) { Thread* thread = (Thread*)arg; t_thread = thread; t_thread_name = thread -> m_name; thread -> m_id = jujimeizuo::GetThreadId(); pthread_setname_np(pthread_self(), thread -> m_name.substr(0, 15).c_str()); std::function cb; cb.swap(thread -> m_cb); thread -> m_semaphere.notify(); cb(); return 0; } 2. 线程同步类 2.1 Semaphore 计数信号量，基于sem_t实现 信号量同样不允许默认拷贝，复制构造，左值构造，所以将默认函数删除。 其中只用一个属性为m_semaphore，为sem_t类型。 在构造函数中sem_init()，在析构函数中sem_destroy()，通过wait()获取，notify()释放。 class Semaphere { public: Semaphere(uint32_t count = 0); ~Semaphere(); void wait(); void notify(); private: Semaphere(const Semaphere&) = delete; Semaphere(const Semaphere&&) = delete; Semaphere& operator=(const Semaphere&) = delete; private: sem_t m_semaphere; }; 2.2 Mutex 互斥锁，基于pthread_mutex_t实现 2.3 RWMutex 读写锁，基于pthread_rwlock_t实现 2.4 Spinlock 自旋锁，基于pthread_spinlock_t实现 2.5 CASLock 原子锁，基于std::atomic_flag实现 2.6 ScopedLockImpl 锁的统一模版封装，对所有锁类统一使用，如果需要换锁，直接替换相应关键字即可。 3. 总结 在日志系统与配置系统使用互斥量是为了保证线程安全，因为日志系统写多读少所以使用Mutex，但有性能要求，所以使用的是Spinlock,在配置系统中是读多写少，所以使用的是读写锁RWmutex。速度大概在每秒25M左右。 在所有需要读取/更改数据的地方都要加锁。 "},"server/Fiber/":{"url":"server/Fiber/","title":"协程模块","keywords":"","body":"协程模块 基于ucontext_t实现非对称协程。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。 1. ucontext_t 实现一个进程中的用户级线程（协程）切换。 // 上下文结构体定义 // 这个结构体是平台相关的，因为不同平台的寄存器不一样 // 下面列出的是所有平台都至少会包含的4个成员 typedef struct ucontext_t { // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效 struct ucontext_t *uc_link; // 当前上下文的信号屏蔽掩码 sigset_t uc_sigmask; // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效 stack_t uc_stack; // 平台相关的上下文具体内容，包含寄存器的值 mcontext_t uc_mcontext; ... } ucontext_t; // 获取当前的上下文 int getcontext(ucontext_t *ucp); // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数 int setcontext(const ucontext_t *ucp); // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数， // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间， // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文， // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了 // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行 void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...); // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中， // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数 // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换 int swapcontext(ucontext_t *oucp, const ucontext_t *ucp); 2. 协程状态 enum State { INIT, // 初始化状态 HOLD, // 暂停状态 EXEC, // 执行中状态 TERM, // 结束状态 READY, // 可执行状态 EXCEPT // 异常状态 }; 3. 协程原语 对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。 4. 协程类 4.1 Fiber 主要成员变量: uint64_t m_id = 0; // 协程id uint32_t m_stacksize = 0; // 协程运行栈大小 State m_state = INIT; // 协程状态 ucontext_t m_ctx; // 协程上下文 void* m_stack = nullptr; // 协程运行栈指针 std::function m_cb; // 协程运行函数 4.2 静态变量 // 全局静态变量，用于生成协程id static std::atomic s_fiber_id{0}; // 全局静态变量，用于统计当前的协程数 static std::atomic s_fiber_count{0}; // 线程局部变量，当前线程正在运行的协程 static thread_local Fiber *t_fiber = nullptr; // 线程局部变量，当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行，智能指针形式 static thread_local Fiber::ptr t_thread_fiber = nullptr; t_fiber：保存当前正在运行的协程指针，必须时刻指向当前正在运行的协程对象。协程模块初始化时，t_fiber指向线程主协程对象。 t_thread_fiber：保存线程主协程指针，智能指针形式。协程模块初始化时，t_thread_fiber指向线程主协程对象。当子协程resume时，通过swapcontext将主协程的上下文保存到t_thread_fiber的ucontext_t成员中，同时激活子协程的ucontext_t上下文。当子协程yield时，从t_thread_fiber中取得主协程的上下文并恢复运行。 4.3 GetThis() 如果存在协程，则返回对象，否则先创建主协程，让t_fiber指向主协程并返回。 缺点：在使用协程之前必须显式调用一次GetThis()。 Fiber::ptr Fiber::GetThis() { if (t_fiber) { return t_fiber -> shared_from_this(); } Fiber::ptr main_fiber(new Fiber); JUJIMEIZUO_ASSERT(t_fiber == main_fiber.get()); t_threadFiber = main_fiber; return t_fiber -> shared_from_this(); } 4.4 MainFunc() 协程入口函数 封装用户的协程入口函数，在函数结束时自动执行yield操作。 void Fiber::MainFunc() { Fiber::ptr cur = GetThis(); // GetThis()的shared_from_this()方法让引用计数加1 JUJIMEIZUO_ASSERT(cur); cur->m_cb(); // 这里真正执行协程的入口函数 cur->m_cb = nullptr; cur->m_state = TERM; auto raw_ptr = cur.get(); // 手动让t_fiber的引用计数减1 cur.reset(); // 重复利用已结束的协程，复用其栈空间，创建新协程 raw_ptr->swapOut(); // 协程结束时自动yield，以回到主协程 } 总结 协程id：通过全局静态变量s_fiber_id的自增来生成协程id，每创建一个新协程，s_fiber_id自增1，并作为新协程的id（实际是先取值，再自增1）。 主协程创建：线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有ucontext_t上下文，但没有入口函数，也没有分配栈空间。 协程切换：子协程的resume操作一定是在主协程里执行的，主协程的resume操作一定是在子协程里执行的。 "}}