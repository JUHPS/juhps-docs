{"./":{"url":"./","title":"首页","keywords":"","body":" High Performance Web Server C++高性能高并发服务器框架 LICENSE 本项目的所有代码均使用基于 GNU General Public License v3.0 开源协议开源，并附加下列条款。部分衍生项目采用 MIT License 开源，以目标仓库内的 LICENSE 文件与 README 说明为准 "},"getStarted/Prepare.html":{"url":"getStarted/Prepare.html","title":"准备工作","keywords":"","body":""},"getStarted/StartJUHPS.html":{"url":"getStarted/StartJUHPS.html","title":"启动系统","keywords":"","body":""},"server/Logger.html":{"url":"server/Logger.html","title":"日志模块","keywords":"","body":"日志模块 用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名/行号，时间戳，线程/协程号，模块名称，日志级别等额外信息，甚至在打印致命的日志时，还应该附加程序的栈回溯信息，以便于分析和排查问题。 1. LogLevel 日志级别 参考log4cpp的设计： enum Level { UNKNOW = 0, DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4, FATAL = 5 }; 2. LogEvent 日志事件 用于记录日志现场，比如该日志的级别，文件名/行号，日志消息，线程/协程号，所属日志器名称等。 3. LogEventWrap 日志事件包装类 将日志事件和日志器包装到一起。因为一条日志只会在一个日志器上进行输出。将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。另外，LogEventWrap还负责在构建时指定日志事件和日志器，在析构时调用日志器的log方法将日志事件进行输出。 4. Logger 日志器 一个Logger包含多个LogAppender和一个日志级别，提供log方法，传入日志事件，判断该日志事件的级别高于日志器本身的级别之后调用LogAppender将日志进行输出，否则该日志被抛弃。 5. LogAppender 日志输出目标 用于将一个日志事件输出到对应的输出地。该类内部包含一个LogFormatter成员和一个log方法，日志事件先经过LogFormatter格式化后再输出到对应的输出地。从这个类可以派生出不同的Appender类型，比如StdoutLogAppender和FileLogAppender，分别表示输出到终端和文件。 6. LogFormatter 日志格式器 与log4cpp的PatternLayout对应，用于格式化一个日志事件。该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。 7. LogManager 日志器管理类 单例模式的设计，用于统一管理所有的日志器，提供日志器的创建与获取方法。LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。 8. Usage 采用宏定义方式 #define JUJIMEIZUO_LOG_DEBUG(logger) JUJIMEIZUO_LOG_LEVEL(logger, jujimeizuo::LogLevel::DEBUG) #define JUJIMEIZUO_LOG_FMT_DEBUG(logger, fmt, ...) JUJIMEIZUO_LOG_FMT_LEVEL(logger, jujimeizuo::LogLevel::DEBUG, fmt, __VA_ARGS__) eg: jujimeizuo::Logger::ptr g_logger = JUJIMEIZUO_LOG_ROOT(); JUJIMEIZUO_LOG_INFO(g_logger) 这里要实现通过g_logger打印一条INFO级别的消息。那么，首先判断INFO级别是否高于g_logger本身的日志级别（这里的设计与原版sylar相反，数字越小，优先级越高），如果不高于，那if语句执行不到，这条日志也不会打印，否则，临时构造一个LogEventWrap对象，传入日志器g_logger，以及现场构造的日志事件。通过LogEventWrap的getLogEvent()方法拿到日志事件，再用日志事件的流式日志消息成员输出日志消息。由于LogEventWrap是在if语句内部构建的，一旦if语句执行结束，LogEventWrap对象就会析构，日志事件也就会被g_logger进行输出。 9. 总结 日志模块的工作流程： 初始化LogFormatter，LogAppender, Logger。 通过宏定义提供流式风格和格式化风格的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，并且将日志事件和日志器Logger包装到一起，生成一个LogEventWrap对象。 日志接口执行结束后，LogEventWrap对象析构，在析构函数里调用Logger的log方法将日志事件进行输出。 "},"server/Config.html":{"url":"server/Config.html","title":"配置模块","keywords":"","body":"配置模块 "},"server/Thread.html":{"url":"server/Thread.html","title":"线程模块","keywords":"","body":"线程模块 提供线程类和线程同步类，基于pthread线程库实现。 1. 线程类 1.1 Thread 构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用std::bind进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。 线程类不提供默认复制、拷贝构造与左值构造，所以将三个默认函数删除掉。 线程类提供五个属性: m_id为pid_t类型，为全局线程id，可以用syscall(SYS_gettid)获取。 m_thread是pthread_t类型，在当前进程中唯一标识线程，可以用pthread_self()函数获取。 m_cb是function类型的属性，是当前线程最终调用的函数。 m_name是当前线程名称可以用于日志输出，调试等等。 m_semaphere是信号量，保护临界资源。 class Thread { public: typedef std::shared_ptr ptr; Thread(std::function cb, const std::string& name); ~Thread(); pid_t getId() const { return m_id; } const std::string& getName() const { return m_name; } void join(); static Thread* GetThis(); static const std::string& GetName(); static void SetName(const std::string& name); private: Thread(const Thread&) = delete; Thread(const Thread&&) = delete; Thread& operator=(const Thread&) = delete; static void* run(void* arg); private: pid_t m_id = -1; pthread_t m_thread = 0; std::function m_cb; std::string m_name; Semaphere m_semaphere; }; Thread类中提供三个静态方法，用于获取当前t_thread和t_thread_name。 Thread::GetThis()、Thread::GetName()、Thread::run()在pthread_create()之前注册，在run()中会完成对两个静态属性的初始化。 pthread_setname_np(pthread_self(), thread->m_name.substr(0, 15).c_str())能够完成在操作系统设置线程名称的任务。 m_semaphore.wait()，在run()中调用真正线程函数之前调用thread->m_semaphore.notify()。是为了保证在完成线程类的构造函数之前，线程已经开始执行了，不然在构造完成之后，线程可能还没开始执行，在离开作用域时会执行析构函数，造成线程还没开始就被pthread_detach()了。 static thread_local Thread* t_thread = nullptr; static thread_local std::string t_thread_name = \"UNKNOW\"; Thread* Thread::GetThis() { return t_thread; } const std::string& Thread::GetName() { return t_thread_name; } void Thread::SetName(const std::string& name) { if (t_thread) { t_thread -> m_name = name; } else { t_thread_name = name; } } void* Thread::run(void* arg) { Thread* thread = (Thread*)arg; t_thread = thread; t_thread_name = thread -> m_name; thread -> m_id = jujimeizuo::GetThreadId(); pthread_setname_np(pthread_self(), thread -> m_name.substr(0, 15).c_str()); std::function cb; cb.swap(thread -> m_cb); thread -> m_semaphere.notify(); cb(); return 0; } 2. 线程同步类 2.1 Semaphore 计数信号量，基于sem_t实现 信号量同样不允许默认拷贝，复制构造，左值构造，所以将默认函数删除。 其中只用一个属性为m_semaphore，为sem_t类型。 在构造函数中sem_init()，在析构函数中sem_destroy()，通过wait()获取，notify()释放。 class Semaphere { public: Semaphere(uint32_t count = 0); ~Semaphere(); void wait(); void notify(); private: Semaphere(const Semaphere&) = delete; Semaphere(const Semaphere&&) = delete; Semaphere& operator=(const Semaphere&) = delete; private: sem_t m_semaphere; }; 2.2 Mutex 互斥锁，基于pthread_mutex_t实现 2.3 RWMutex 读写锁，基于pthread_rwlock_t实现 2.4 Spinlock 自旋锁，基于pthread_spinlock_t实现 2.5 CASLock 原子锁，基于std::atomic_flag实现 2.6 ScopedLockImpl 锁的统一模版封装，对所有锁类统一使用，如果需要换锁，直接替换相应关键字即可。 3. 总结 在日志系统与配置系统使用互斥量是为了保证线程安全，因为日志系统写多读少所以使用Mutex，但有性能要求，所以使用的是Spinlock,在配置系统中是读多写少，所以使用的是读写锁RWmutex。速度大概在每秒25M左右。 在所有需要读取/更改数据的地方都要加锁。 "}}