{"./":{"url":"./","title":"首页","keywords":"","body":" High Performance Web Server C++高性能高并发服务器框架 LICENSE 本项目的所有代码均使用基于 GNU General Public License v3.0 开源协议开源，并附加下列条款。部分衍生项目采用 MIT License 开源，以目标仓库内的 LICENSE 文件与 README 说明为准 "},"Welcome.html":{"url":"Welcome.html","title":"介绍","keywords":"","body":""},"getStarted/":{"url":"getStarted/","title":"开始部署","keywords":"","body":""},"getStarted/common/Prepare.html":{"url":"getStarted/common/Prepare.html","title":"准备工作","keywords":"","body":""},"getStarted/common/StartJUHPS.html":{"url":"getStarted/common/StartJUHPS.html","title":"启动系统","keywords":"","body":""},"server/":{"url":"server/","title":"服务器","keywords":"","body":" 日志模块 线程模块 \\ 配置模块 协程模块 \\ 协程调度模块 \\ \\ "},"server/Logger/":{"url":"server/Logger/","title":"日志模块","keywords":"","body":"日志模块 用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名/行号，时间戳，线程/协程号，模块名称，日志级别等额外信息，甚至在打印致命的日志时，还应该附加程序的栈回溯信息，以便于分析和排查问题。 1. 模块设计 从设计上看，一个完整的日志模块应该具备以下功能： 区分不同的级别，比如常的DEBUG/INFO/WARN/ERROR等级别。日志模块可以通过指定级别实现只输出某个级别以上的日志，这样可以灵活开关一些不重要的日志输出，比如程序在调试阶段可以设置一个较低的级别，以便看到更多的调度日志信息，程序发布之后可以设置一个较高的级别，以减少日志输出，提高性能。 区分不同的输出地。不同的日志可以输出到不同的位置，比如可以输出到标准输出，输出到文件，输出到syslog，输出到网络上的日志服务器等，甚至同一条日志可以同时输出到多个输出地。 区分不同的类别。日志可以分类并命名，一个程序的各个模块可以使用不同的名称来输出日志，这样可以很方便地判断出当前日志是哪个程序模块输出的。 日志格式可灵活配置。可以按需指定每条日志是否包含文件名/行号、时间戳、线程/协程号、日志级别、启动时间等内容。 可通过配置文件的方式配置以上功能。 2. 模块实现 2.1 LogLevel 日志级别 参考log4cpp的设计： enum Level { UNKNOW = 0, DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4, FATAL = 5 }; 2.2 LogEvent 日志事件 用于记录日志现场，比如该日志的级别，文件名/行号，日志消息，线程/协程号，所属日志器名称等。 2.3 LogEventWrap 日志事件包装类 将日志事件和日志器包装到一起。因为一条日志只会在一个日志器上进行输出。将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。另外，LogEventWrap还负责在构建时指定日志事件和日志器，在析构时调用日志器的log方法将日志事件进行输出。 2.4 Logger 日志器 一个Logger包含多个LogAppender和一个日志级别，提供log方法，传入日志事件，判断该日志事件的级别高于日志器本身的级别之后调用LogAppender将日志进行输出，否则该日志被抛弃。 2.5 LogAppender 日志输出目标 用于将一个日志事件输出到对应的输出地。该类内部包含一个LogFormatter成员和一个log方法，日志事件先经过LogFormatter格式化后再输出到对应的输出地。从这个类可以派生出不同的Appender类型，比如StdoutLogAppender和FileLogAppender，分别表示输出到终端和文件。 2.6 LogFormatter 日志格式器 与log4cpp的PatternLayout对应，用于格式化一个日志事件。该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。 2.7 LogManager 日志器管理类 单例模式的设计，用于统一管理所有的日志器，提供日志器的创建与获取方法。LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。 2.8 Usage 采用宏定义方式 #define JUJIMEIZUO_LOG_DEBUG(logger) JUJIMEIZUO_LOG_LEVEL(logger, jujimeizuo::LogLevel::DEBUG) #define JUJIMEIZUO_LOG_FMT_DEBUG(logger, fmt, ...) JUJIMEIZUO_LOG_FMT_LEVEL(logger, jujimeizuo::LogLevel::DEBUG, fmt, __VA_ARGS__) eg: jujimeizuo::Logger::ptr g_logger = JUJIMEIZUO_LOG_ROOT(); JUJIMEIZUO_LOG_INFO(g_logger) 这里要实现通过g_logger打印一条INFO级别的消息。那么，首先判断INFO级别是否高于g_logger本身的日志级别（这里的设计与原版sylar相反，数字越小，优先级越高），如果不高于，那if语句执行不到，这条日志也不会打印，否则，临时构造一个LogEventWrap对象，传入日志器g_logger，以及现场构造的日志事件。通过LogEventWrap的getLogEvent()方法拿到日志事件，再用日志事件的流式日志消息成员输出日志消息。由于LogEventWrap是在if语句内部构建的，一旦if语句执行结束，LogEventWrap对象就会析构，日志事件也就会被g_logger进行输出。 3. 总结 日志模块的工作流程： 初始化LogFormatter，LogAppender, Logger。 通过宏定义提供流式风格和格式化风格的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，并且将日志事件和日志器Logger包装到一起，生成一个LogEventWrap对象。 日志接口执行结束后，LogEventWrap对象析构，在析构函数里调用Logger的log方法将日志事件进行输出。 "},"server/Config/":{"url":"server/Config/","title":"配置模块","keywords":"","body":"配置模块 用于定义/声明配置项，并且从配置文件中加载用户配置，体现约定大于配置的思想，配置文件采用yml，并用yaml-cpp进行解析，用片特化的方式实现数据类型的序列化和反序列，并用回调函数的机制使其生效。 参考谷歌开源的基于命令行的C++配置库：gflags 1. 模块设计 采用约定优于配置的思想 简单来说，约定优于配置的背景条件是，一般来说，程序所依赖的配置项都有一个公认的默认值，也就是所谓的约定。这点有可许多可以参考的例子，比如对于一个http网络服务器，服务端口通常都是80端口，对于配置文件夹路径，一般都是conf文件夹，对于数据库目录，一般都是db或data文件夹。对于这些具有公认约定的配置，就不需要麻烦程序员在程序跑起来后再一项一项地指定了，而是可以初始时就将配置项设置成对应的值。这样，程序员就可以只修改那些约定之外的配置项，然后以最小的代价让程序跑起来。 约定优于配置的方式可以减少程序员做决定的数量，获得简单的好处，同时兼顾灵活性。 一般而言，一项配置应该包括以下要素： 名称，对应一个字符串，必须唯一，不能与其他配置项产生冲突。 类型，可以是基本类型，但也应该支持复杂类型和自定义类型。 值。 默认值，考虑到用户不一定总是会显式地给配置项赋值，所以配置项最好有一个默认值。 配置变更通知，一旦用户更新了配置值，那么应该通知所有使用了这项配置的代码，以便于进行一些具体的操作，比如重新打开文件，重新起监听端口等。 校验方法，更新配置时会调用校验方法进行校验，以保证用户不会给配置项设置一个非法的值。 一个配置模块应具备的基本功能： 支持定义/声明配置项，也就是在提供配置名称、类型以及可选的默认值的情况下生成一个可用的配置项。由于一项配置可能在多个源文件中使用，所以配置模块还应该支持跨文件声明配置项的方法。 支持更新配置项的值。这点很好理解，配置项刚被定义时可能有一个初始默认值，但用户可能会有新的值来覆盖掉原来的值。 支持从预置的途径中加载配置项，一般是配置文件，也可以是命令行参数，或是网络服务器。这里不仅应该支持基本数据类型的加载，也应该支持复杂数据类型的加载，比如直接从配置文件中加载一个map类型的配置项，或是直接从一个预定格式的配置文件中加载一个自定义结构体。 支持给配置项注册配置变更通知。配置模块应该提供方法让程序知道某项配置被修改了，以便于进行一些操作。比如对于网络服务器而言，如果服务器端口配置变化了，那程序应该重新起监听端口。这个功能一般是通过注册回调函数来实现的，配置使用方预先给配置项注册一个配置变更回调函数，配置项发生变化时，触发对应的回调函数以通知调用方。由于一项配置可能在多个地方引用，所以配置变更回调函数应该是一个数组的形式。 支持给配置项设置校验方法。配置项在定义时也可以指定一个校验方法，以保证该项配置不会被设置成一个非法的值，比如对于文件路径类的配置，可以通过校验方法来确保该路径一定存在。 支持导出当前配置。 2. 模块实现 2.1 ConfigVarBase 配置项基类 每个配置项都包括name和description，以及toString()和fromString()两个纯虚函数，用于和YAML字符串进行相互转换。但并不包括配置项类型和值，由继承类实现。 不区分大小写，全部用transform()转成小写进行配置。 2.2 ConfigVar 配置参数类（继承ConfigVarBase） 2.2.1 定义成模版类 template , class ToStr = LexicalCast > T为配置项的类型，FromStr()和ToStr()用于YAML字符串的转换，并根据不同的T实现不同的片特化。 2.2.2 支持变更配置 setValue/getValue方法用于获取/更新配置值（更新配置时会一并触发全部的配置变更回调函数）\\ addListener/delListener方法用于添加或删除配置变更回调函数。 2.3 Config 配置管理类 负责托管ConfigVar对象。 所有成员都为static，保证全局只有一个实例。 2.3.1 Lookup 用于根据配置名称查询配置项。 如果调用Lookup查询时同时提供了默认值和配置项的描述信息，那么在未找到对应的配置时，会自动创建一个对应的配置项，这样就保证了配置模块定义即可用的特性。 2.3.2 LoadFromYaml 从YAML对象加载配置。 2.4 yaml-cpp 项目的配置文件采用yml，并用yaml-cpp库进行解析。 对于每种类型的配置，在对应的ConfigVar模版类实例化时都要提供FromStr和ToStr两个仿函数，用于实现该类型和YAML字符串的相互转换。 对于每种数据类型，包括自定义数据类型，都需要片特化。从一个基本类型的转换类开始，特化出其他类型的转换类。 template class LexicalCast { public: /** * @brief 类型转换 * @param[in] v 源类型值 * @return 返回v转换后的目标类型 * @exception 当类型不可转换时抛出异常 */ T operator()(const F& v) { return boost::lexical_cast(v); } }; 实现了int、vector、set、map等类型，根据这些类型的搭配，还实现其他复杂类型，例如vector、set等等。 2.5 Usage YAML::Node root = YAML::LoadFile(\"url/*.yml\"); jujimeizuo::Config::LoadFromYaml(root); 2.5.1 unordered_map做配置 jujimeizuo::ConfigVar >::ptr g_str_int_unordered_map_value_config = jujimeizuo::Config::Lookup(\"system.str_int_unordered_map\", std::unordered_map{{\"k\", 2}}, \"system str int unordered_map\"); 2022-09-01 00:03:24 4294967295 0 [INFO] [root] /Users/fengzetao/Desktop/WebServer/tests/test_config.cc:142 after str_int_unordered_map: {k2 - 20} 3. 总结 采用约定由于配置的思想。定义即可使用。不需要单独去解析。支持变更通知功能。使用YAML文件做为配置内容。支持级别格式的数据类型，支持STL容器(vector,list,set,map等等),支持自定义类型的支持（需要实现序列化和反序列化方法)。 通过配置系统对日志进行配置需要对日志里的类型进行片特化处理，这样在处理序列化与反序列化的时候才能识别yml文件中的log配置。具体在LogDefine和LogAppenderDefine。 "},"server/Thread/":{"url":"server/Thread/","title":"线程模块","keywords":"","body":"线程模块 提供线程类和线程同步类，基于pthread线程库实现。 1. 模块设计 一个线程模块应该具有的功能： 创建线程，支持多线程。 具备线程同步和线程互斥。 具备各种锁的应用，并测试锁的性能选择最佳方案。 2. 模块实现 2.1 线程类 2.1.1 Thread 构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用std::bind进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。 线程类不提供默认复制、拷贝构造与左值构造，所以将三个默认函数删除掉。 线程类提供五个属性: m_id为pid_t类型，为全局线程id，可以用syscall(SYS_gettid)获取。 m_thread是pthread_t类型，在当前进程中唯一标识线程，可以用pthread_self()函数获取。 m_cb是function类型的属性，是当前线程最终调用的函数。 m_name是当前线程名称可以用于日志输出，调试等等。 m_semaphere是信号量，保护临界资源。 class Thread { public: typedef std::shared_ptr ptr; Thread(std::function cb, const std::string& name); ~Thread(); pid_t getId() const { return m_id; } const std::string& getName() const { return m_name; } void join(); static Thread* GetThis(); static const std::string& GetName(); static void SetName(const std::string& name); private: Thread(const Thread&) = delete; Thread(const Thread&&) = delete; Thread& operator=(const Thread&) = delete; static void* run(void* arg); private: pid_t m_id = -1; pthread_t m_thread = 0; std::function m_cb; std::string m_name; Semaphere m_semaphere; }; Thread类中提供三个静态方法，用于获取当前t_thread和t_thread_name。 Thread::GetThis()、Thread::GetName()、Thread::run()在pthread_create()之前注册，在run()中会完成对两个静态属性的初始化。 pthread_setname_np(pthread_self(), thread->m_name.substr(0, 15).c_str())能够完成在操作系统设置线程名称的任务。 m_semaphore.wait()，在run()中调用真正线程函数之前调用thread->m_semaphore.notify()。是为了保证在完成线程类的构造函数之前，线程已经开始执行了，不然在构造完成之后，线程可能还没开始执行，在离开作用域时会执行析构函数，造成线程还没开始就被pthread_detach()了。 static thread_local Thread* t_thread = nullptr; static thread_local std::string t_thread_name = \"UNKNOW\"; Thread* Thread::GetThis() { return t_thread; } const std::string& Thread::GetName() { return t_thread_name; } void Thread::SetName(const std::string& name) { if (t_thread) { t_thread -> m_name = name; } else { t_thread_name = name; } } void* Thread::run(void* arg) { Thread* thread = (Thread*)arg; t_thread = thread; t_thread_name = thread -> m_name; thread -> m_id = jujimeizuo::GetThreadId(); pthread_setname_np(pthread_self(), thread -> m_name.substr(0, 15).c_str()); std::function cb; cb.swap(thread -> m_cb); thread -> m_semaphere.notify(); cb(); return 0; } 2.2 线程同步类 2.2.1 Semaphore 计数信号量，基于sem_t实现 信号量同样不允许默认拷贝，复制构造，左值构造，所以将默认函数删除。 其中只用一个属性为m_semaphore，为sem_t类型。 在构造函数中sem_init()，在析构函数中sem_destroy()，通过wait()获取，notify()释放。 class Semaphere { public: Semaphere(uint32_t count = 0); ~Semaphere(); void wait(); void notify(); private: Semaphere(const Semaphere&) = delete; Semaphere(const Semaphere&&) = delete; Semaphere& operator=(const Semaphere&) = delete; private: sem_t m_semaphere; }; 2.2.2 Mutex 互斥锁，基于pthread_mutex_t实现 2.2.3 RWMutex 读写锁，基于pthread_rwlock_t实现 2.2.4 Spinlock 自旋锁，基于pthread_spinlock_t实现 2.2.5 CASLock 原子锁，基于std::atomic_flag实现 2.2.6 ScopedLockImpl 锁的统一模版封装，对所有锁类统一使用，如果需要换锁，直接替换相应关键字即可。 3. 总结 在日志系统与配置系统使用互斥量是为了保证线程安全，因为日志系统写多读少所以使用Mutex，但有性能要求，所以使用的是Spinlock,在配置系统中是读多写少，所以使用的是读写锁RWmutex。速度大概在每秒25M左右。 在所有需要读取/更改数据的地方都要加锁。 "},"server/Fiber/":{"url":"server/Fiber/","title":"协程模块","keywords":"","body":"协程模块 基于ucontext_t实现非对称协程。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。 1. ucontext_t 实现一个进程中的用户级线程（协程）切换。 // 上下文结构体定义 // 这个结构体是平台相关的，因为不同平台的寄存器不一样 // 下面列出的是所有平台都至少会包含的4个成员 typedef struct ucontext_t { // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效 struct ucontext_t *uc_link; // 当前上下文的信号屏蔽掩码 sigset_t uc_sigmask; // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效 stack_t uc_stack; // 平台相关的上下文具体内容，包含寄存器的值 mcontext_t uc_mcontext; ... } ucontext_t; // 获取当前的上下文 int getcontext(ucontext_t *ucp); // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数 int setcontext(const ucontext_t *ucp); // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数， // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间， // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文， // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了 // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行 void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...); // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中， // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数 // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换 int swapcontext(ucontext_t *oucp, const ucontext_t *ucp); 2. 模块设计 使用非对称协程模型，也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。 在对称协程中，子协程可以直接和子协程切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。而在非对称协程中，可以借助专门的调度器来负责调度协程，每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。 非对称协程的行为与函数类似，因为函数在运行结束后也总是会返回调用者。 虽然目前还没有涉及到协程调度，但这里其实可以将线程的主协程想像成线程的调度协程，每个子协程执行完了，都必须切回线程主协程，由主协程负责选出下一个要执行的子协程。如果子协程可以和子协程切换，那就相当于变相赋予了子协程调度的权利，这在非对称协程里是不允许的。 借助了线程局部变量的功能来实现协程模块。线程局部变量与全局变量类似，不同之处在于声明的线程局部变量在每个线程都独有一份，而全局变量是全部线程共享一份。 使用线程局部变量（C++11 thread_local变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。 对于每个线程的协程上下文，设计了两个线程局部变量来存储上下文信息（对应源码的t_fiber和t_thread_fiber），也就是说，一个线程在任何时候最多只能知道两个协程的上下文。又由于只使用swapcontext来做协程切换，那就意味着，这两个线程局部变量必须至少有一个是用来保存线程主协程的上下文的，如果这两个线程局部变量存储的都是子协程的上下文，那么不管怎么调用swapcontext，都没法恢复主协程的上下文，也就意味着程序最终无法回到主协程去执行，程序也就跑飞了。 如果将线程的局部变量设置成一个类似链表的数据结构，那理论上应该也可以实现对称协程，也就是子协程可以直接和子协程切换，但代码复杂度上肯定会增加不少，因为要考虑多线程和公平调度的问题。 非对称协程代码实现简单，并且在后面实现协程调度时可以做到公平调度，缺点是子协程只能和线程主协程切换，意味着子协程无法创建并运行新的子协程，并且在后面实现协程调度时，完成一次子协程调度需要额外多切换一次上下文。 3. 模块实现 3.1 协程状态 enum State { INIT, // 初始化状态 HOLD, // 暂停状态 EXEC, // 执行中状态 TERM, // 结束状态 READY, // 可执行状态 EXCEPT // 异常状态 }; 3.2 协程原语 对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。 3.3 协程类 3.3.1 Fiber 主要成员变量: uint64_t m_id = 0; // 协程id uint32_t m_stacksize = 0; // 协程运行栈大小 State m_state = INIT; // 协程状态 ucontext_t m_ctx; // 协程上下文 void* m_stack = nullptr; // 协程运行栈指针 std::function m_cb; // 协程运行函数 3.3.2 静态变量 // 全局静态变量，用于生成协程id static std::atomic s_fiber_id{0}; // 全局静态变量，用于统计当前的协程数 static std::atomic s_fiber_count{0}; // 线程局部变量，当前线程正在运行的协程 static thread_local Fiber *t_fiber = nullptr; // 线程局部变量，当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行，智能指针形式 static thread_local Fiber::ptr t_thread_fiber = nullptr; t_fiber：保存当前正在运行的协程指针，必须时刻指向当前正在运行的协程对象。协程模块初始化时，t_fiber指向线程主协程对象。 t_thread_fiber：保存线程主协程指针，智能指针形式。协程模块初始化时，t_thread_fiber指向线程主协程对象。当子协程resume时，通过swapcontext将主协程的上下文保存到t_thread_fiber的ucontext_t成员中，同时激活子协程的ucontext_t上下文。当子协程yield时，从t_thread_fiber中取得主协程的上下文并恢复运行。 3.3.3 GetThis() 如果存在协程，则返回对象，否则先创建主协程，让t_fiber指向主协程并返回。 缺点：在使用协程之前必须显式调用一次GetThis()。 Fiber::ptr Fiber::GetThis() { if (t_fiber) { return t_fiber -> shared_from_this(); } Fiber::ptr main_fiber(new Fiber); JUJIMEIZUO_ASSERT(t_fiber == main_fiber.get()); t_threadFiber = main_fiber; return t_fiber -> shared_from_this(); } 3.3.4 MainFunc() 协程入口函数 封装用户的协程入口函数，在函数结束时自动执行yield操作。 void Fiber::MainFunc() { Fiber::ptr cur = GetThis(); // GetThis()的shared_from_this()方法让引用计数加1 JUJIMEIZUO_ASSERT(cur); cur->m_cb(); // 这里真正执行协程的入口函数 cur->m_cb = nullptr; cur->m_state = TERM; auto raw_ptr = cur.get(); // 手动让t_fiber的引用计数减1 cur.reset(); // 重复利用已结束的协程，复用其栈空间，创建新协程 raw_ptr->swapOut(); // 协程结束时自动yield，以回到主协程 } 总结 协程id：通过全局静态变量s_fiber_id的自增来生成协程id，每创建一个新协程，s_fiber_id自增1，并作为新协程的id（实际是先取值，再自增1）。 主协程创建：线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有ucontext_t上下文，但没有入口函数，也没有分配栈空间。 协程切换：子协程的resume操作一定是在主协程里执行的，主协程的resume操作一定是在子协程里执行的。 "},"server/Scheduler/":{"url":"server/Scheduler/","title":"协程调度模块","keywords":"","body":"线程调度模块 实现了一个N-M的协程调度器，N个线程运行M个协程，协程可以在线程之间进行切换，也可以绑定到指定线程运行。 实现协程调度之后，可以解决协程模块中子协程不能运行另一个子协程的缺陷，子协程可以通过向调度器添加调度任务的方式来运行另一个子协程。 1. 模块设计 2. 模块实现 总结 "}}