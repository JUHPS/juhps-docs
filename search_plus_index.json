{"./":{"url":"./","title":"首页","keywords":"","body":" High Performance Web Server C++高性能高并发服务器框架 LICENSE 本项目的所有代码均使用基于 GNU General Public License v3.0 开源协议开源，并附加下列条款。部分衍生项目采用 MIT License 开源，以目标仓库内的 LICENSE 文件与 README 说明为准 "},"Welcome.html":{"url":"Welcome.html","title":"介绍","keywords":"","body":""},"getStarted/":{"url":"getStarted/","title":"开始部署","keywords":"","body":""},"getStarted/common/Prepare.html":{"url":"getStarted/common/Prepare.html","title":"准备工作","keywords":"","body":""},"getStarted/common/StartJUHPS.html":{"url":"getStarted/common/StartJUHPS.html","title":"启动系统","keywords":"","body":""},"server/":{"url":"server/","title":"服务器","keywords":"","body":" 日志模块 \\ \\ 配置模块 \\ \\ \\ 线程模块 \\ \\ 协程模块 \\ \\ 协程调度模块 \\ \\ IO协程调度模块 \\ \\ 定时器模块 \\ Hook模块 \\ \\ \\ \\ 网络地址模块 \\ \\ Socket模块 ByteArray序列化模块 \\ \\ \\ \\ 字节流模块 \\ \\ TcpServer模块 "},"server/Logger/":{"url":"server/Logger/","title":"日志模块","keywords":"","body":"日志模块 用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名/行号，时间戳，线程/协程号，模块名称，日志级别等额外信息，甚至在打印致命的日志时，还应该附加程序的栈回溯信息，以便于分析和排查问题。 1. 模块设计 从设计上看，一个完整的日志模块应该具备以下功能： 区分不同的级别，比如常的DEBUG/INFO/WARN/ERROR等级别。日志模块可以通过指定级别实现只输出某个级别以上的日志，这样可以灵活开关一些不重要的日志输出，比如程序在调试阶段可以设置一个较低的级别，以便看到更多的调度日志信息，程序发布之后可以设置一个较高的级别，以减少日志输出，提高性能。 区分不同的输出地。不同的日志可以输出到不同的位置，比如可以输出到标准输出，输出到文件，输出到syslog，输出到网络上的日志服务器等，甚至同一条日志可以同时输出到多个输出地。 区分不同的类别。日志可以分类并命名，一个程序的各个模块可以使用不同的名称来输出日志，这样可以很方便地判断出当前日志是哪个程序模块输出的。 日志格式可灵活配置。可以按需指定每条日志是否包含文件名/行号、时间戳、线程/协程号、日志级别、启动时间等内容。 可通过配置文件的方式配置以上功能。 2. 模块实现 2.1 LogLevel 日志级别 参考log4cpp的设计： enum Level { UNKNOW = 0, DEBUG = 1, INFO = 2, WARN = 3, ERROR = 4, FATAL = 5 }; 2.2 LogEvent 日志事件 用于记录日志现场，比如该日志的级别，文件名/行号，日志消息，线程/协程号，所属日志器名称等。 2.3 LogEventWrap 日志事件包装类 将日志事件和日志器包装到一起。因为一条日志只会在一个日志器上进行输出。将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。另外，LogEventWrap还负责在构建时指定日志事件和日志器，在析构时调用日志器的log方法将日志事件进行输出。 2.4 Logger 日志器 一个Logger包含多个LogAppender和一个日志级别，提供log方法，传入日志事件，判断该日志事件的级别高于日志器本身的级别之后调用LogAppender将日志进行输出，否则该日志被抛弃。 2.5 LogAppender 日志输出目标 用于将一个日志事件输出到对应的输出地。该类内部包含一个LogFormatter成员和一个log方法，日志事件先经过LogFormatter格式化后再输出到对应的输出地。从这个类可以派生出不同的Appender类型，比如StdoutLogAppender和FileLogAppender，分别表示输出到终端和文件。 2.6 LogFormatter 日志格式器 与log4cpp的PatternLayout对应，用于格式化一个日志事件。该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。 2.7 LogManager 日志器管理类 单例模式的设计，用于统一管理所有的日志器，提供日志器的创建与获取方法。LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。 2.8 Usage 采用宏定义方式 #define JUJIMEIZUO_LOG_DEBUG(logger) JUJIMEIZUO_LOG_LEVEL(logger, jujimeizuo::LogLevel::DEBUG) #define JUJIMEIZUO_LOG_FMT_DEBUG(logger, fmt, ...) JUJIMEIZUO_LOG_FMT_LEVEL(logger, jujimeizuo::LogLevel::DEBUG, fmt, __VA_ARGS__) eg: jujimeizuo::Logger::ptr g_logger = JUJIMEIZUO_LOG_ROOT(); JUJIMEIZUO_LOG_INFO(g_logger) 这里要实现通过g_logger打印一条INFO级别的消息。那么，首先判断INFO级别是否高于g_logger本身的日志级别（这里的设计与原版sylar相反，数字越小，优先级越高），如果不高于，那if语句执行不到，这条日志也不会打印，否则，临时构造一个LogEventWrap对象，传入日志器g_logger，以及现场构造的日志事件。通过LogEventWrap的getLogEvent()方法拿到日志事件，再用日志事件的流式日志消息成员输出日志消息。由于LogEventWrap是在if语句内部构建的，一旦if语句执行结束，LogEventWrap对象就会析构，日志事件也就会被g_logger进行输出。 3. 总结 日志模块的工作流程： 初始化LogFormatter，LogAppender, Logger。 通过宏定义提供流式风格和格式化风格的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，并且将日志事件和日志器Logger包装到一起，生成一个LogEventWrap对象。 日志接口执行结束后，LogEventWrap对象析构，在析构函数里调用Logger的log方法将日志事件进行输出。 "},"server/Config/":{"url":"server/Config/","title":"配置模块","keywords":"","body":"配置模块 用于定义/声明配置项，并且从配置文件中加载用户配置，体现约定大于配置的思想，配置文件采用yml，并用yaml-cpp进行解析，用片特化的方式实现数据类型的序列化和反序列，并用回调函数的机制使其生效。 参考谷歌开源的基于命令行的C++配置库：gflags 1. 模块设计 采用约定优于配置的思想 简单来说，约定优于配置的背景条件是，一般来说，程序所依赖的配置项都有一个公认的默认值，也就是所谓的约定。这点有可许多可以参考的例子，比如对于一个http网络服务器，服务端口通常都是80端口，对于配置文件夹路径，一般都是conf文件夹，对于数据库目录，一般都是db或data文件夹。对于这些具有公认约定的配置，就不需要麻烦程序员在程序跑起来后再一项一项地指定了，而是可以初始时就将配置项设置成对应的值。这样，程序员就可以只修改那些约定之外的配置项，然后以最小的代价让程序跑起来。 约定优于配置的方式可以减少程序员做决定的数量，获得简单的好处，同时兼顾灵活性。 一般而言，一项配置应该包括以下要素： 名称，对应一个字符串，必须唯一，不能与其他配置项产生冲突。 类型，可以是基本类型，但也应该支持复杂类型和自定义类型。 值。 默认值，考虑到用户不一定总是会显式地给配置项赋值，所以配置项最好有一个默认值。 配置变更通知，一旦用户更新了配置值，那么应该通知所有使用了这项配置的代码，以便于进行一些具体的操作，比如重新打开文件，重新起监听端口等。 校验方法，更新配置时会调用校验方法进行校验，以保证用户不会给配置项设置一个非法的值。 一个配置模块应具备的基本功能： 支持定义/声明配置项，也就是在提供配置名称、类型以及可选的默认值的情况下生成一个可用的配置项。由于一项配置可能在多个源文件中使用，所以配置模块还应该支持跨文件声明配置项的方法。 支持更新配置项的值。这点很好理解，配置项刚被定义时可能有一个初始默认值，但用户可能会有新的值来覆盖掉原来的值。 支持从预置的途径中加载配置项，一般是配置文件，也可以是命令行参数，或是网络服务器。这里不仅应该支持基本数据类型的加载，也应该支持复杂数据类型的加载，比如直接从配置文件中加载一个map类型的配置项，或是直接从一个预定格式的配置文件中加载一个自定义结构体。 支持给配置项注册配置变更通知。配置模块应该提供方法让程序知道某项配置被修改了，以便于进行一些操作。比如对于网络服务器而言，如果服务器端口配置变化了，那程序应该重新起监听端口。这个功能一般是通过注册回调函数来实现的，配置使用方预先给配置项注册一个配置变更回调函数，配置项发生变化时，触发对应的回调函数以通知调用方。由于一项配置可能在多个地方引用，所以配置变更回调函数应该是一个数组的形式。 支持给配置项设置校验方法。配置项在定义时也可以指定一个校验方法，以保证该项配置不会被设置成一个非法的值，比如对于文件路径类的配置，可以通过校验方法来确保该路径一定存在。 支持导出当前配置。 2. 模块实现 2.1 ConfigVarBase 配置项基类 每个配置项都包括name和description，以及toString()和fromString()两个纯虚函数，用于和YAML字符串进行相互转换。但并不包括配置项类型和值，由继承类实现。 不区分大小写，全部用transform()转成小写进行配置。 2.2 ConfigVar 配置参数类（继承ConfigVarBase） 2.2.1 定义成模版类 template , class ToStr = LexicalCast > T为配置项的类型，FromStr()和ToStr()用于YAML字符串的转换，并根据不同的T实现不同的片特化。 2.2.2 支持变更配置 setValue/getValue方法用于获取/更新配置值（更新配置时会一并触发全部的配置变更回调函数）\\ addListener/delListener方法用于添加或删除配置变更回调函数。 2.3 Config 配置管理类 负责托管ConfigVar对象。 所有成员都为static，保证全局只有一个实例。 2.3.1 Lookup 用于根据配置名称查询配置项。 如果调用Lookup查询时同时提供了默认值和配置项的描述信息，那么在未找到对应的配置时，会自动创建一个对应的配置项，这样就保证了配置模块定义即可用的特性。 2.3.2 LoadFromYaml 从YAML对象加载配置。 2.4 yaml-cpp 项目的配置文件采用yml，并用yaml-cpp库进行解析。 对于每种类型的配置，在对应的ConfigVar模版类实例化时都要提供FromStr和ToStr两个仿函数，用于实现该类型和YAML字符串的相互转换。 对于每种数据类型，包括自定义数据类型，都需要片特化。从一个基本类型的转换类开始，特化出其他类型的转换类。 template class LexicalCast { public: /** * @brief 类型转换 * @param[in] v 源类型值 * @return 返回v转换后的目标类型 * @exception 当类型不可转换时抛出异常 */ T operator()(const F& v) { return boost::lexical_cast(v); } }; 实现了int、vector、set、map等类型，根据这些类型的搭配，还实现其他复杂类型，例如vector、set等等。 2.5 Usage YAML::Node root = YAML::LoadFile(\"url/*.yml\"); jujimeizuo::Config::LoadFromYaml(root); 2.5.1 unordered_map做配置 jujimeizuo::ConfigVar >::ptr g_str_int_unordered_map_value_config = jujimeizuo::Config::Lookup(\"system.str_int_unordered_map\", std::unordered_map{{\"k\", 2}}, \"system str int unordered_map\"); 2022-09-01 00:03:24 4294967295 0 [INFO] [root] /Users/fengzetao/Desktop/WebServer/tests/test_config.cc:142 after str_int_unordered_map: {k2 - 20} 3. 总结 采用约定由于配置的思想。定义即可使用。不需要单独去解析。支持变更通知功能。使用YAML文件做为配置内容。支持级别格式的数据类型，支持STL容器(vector,list,set,map等等),支持自定义类型的支持（需要实现序列化和反序列化方法)。 通过配置系统对日志进行配置需要对日志里的类型进行片特化处理，这样在处理序列化与反序列化的时候才能识别yml文件中的log配置。具体在LogDefine和LogAppenderDefine。 "},"server/Thread/":{"url":"server/Thread/","title":"线程模块","keywords":"","body":"线程模块 提供线程类和线程同步类，基于pthread线程库实现。 1. 模块设计 一个线程模块应该具有的功能： 创建线程，支持多线程。 具备线程同步和线程互斥。 具备各种锁的应用，并测试锁的性能选择最佳方案。 2. 模块实现 2.1 线程类 2.1.1 Thread 构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用std::bind进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。 线程类不提供默认复制、拷贝构造与左值构造，所以将三个默认函数删除掉。 线程类提供五个属性: m_id为pid_t类型，为全局线程id，可以用syscall(SYS_gettid)获取。 m_thread是pthread_t类型，在当前进程中唯一标识线程，可以用pthread_self()函数获取。 m_cb是function类型的属性，是当前线程最终调用的函数。 m_name是当前线程名称可以用于日志输出，调试等等。 m_semaphere是信号量，保护临界资源。 class Thread { public: typedef std::shared_ptr ptr; Thread(std::function cb, const std::string& name); ~Thread(); pid_t getId() const { return m_id; } const std::string& getName() const { return m_name; } void join(); static Thread* GetThis(); static const std::string& GetName(); static void SetName(const std::string& name); private: Thread(const Thread&) = delete; Thread(const Thread&&) = delete; Thread& operator=(const Thread&) = delete; static void* run(void* arg); private: pid_t m_id = -1; pthread_t m_thread = 0; std::function m_cb; std::string m_name; Semaphere m_semaphere; }; Thread类中提供三个静态方法，用于获取当前t_thread和t_thread_name。 Thread::GetThis()、Thread::GetName()、Thread::run()在pthread_create()之前注册，在run()中会完成对两个静态属性的初始化。 pthread_setname_np(pthread_self(), thread->m_name.substr(0, 15).c_str())能够完成在操作系统设置线程名称的任务。 m_semaphore.wait()，在run()中调用真正线程函数之前调用thread->m_semaphore.notify()。是为了保证在完成线程类的构造函数之前，线程已经开始执行了，不然在构造完成之后，线程可能还没开始执行，在离开作用域时会执行析构函数，造成线程还没开始就被pthread_detach()了。 static thread_local Thread* t_thread = nullptr; static thread_local std::string t_thread_name = \"UNKNOW\"; Thread* Thread::GetThis() { return t_thread; } const std::string& Thread::GetName() { return t_thread_name; } void Thread::SetName(const std::string& name) { if (t_thread) { t_thread -> m_name = name; } else { t_thread_name = name; } } void* Thread::run(void* arg) { Thread* thread = (Thread*)arg; t_thread = thread; t_thread_name = thread -> m_name; thread -> m_id = jujimeizuo::GetThreadId(); pthread_setname_np(pthread_self(), thread -> m_name.substr(0, 15).c_str()); std::function cb; cb.swap(thread -> m_cb); thread -> m_semaphere.notify(); cb(); return 0; } 2.2 线程同步类 2.2.1 Semaphore 计数信号量，基于sem_t实现 信号量同样不允许默认拷贝，复制构造，左值构造，所以将默认函数删除。 其中只用一个属性为m_semaphore，为sem_t类型。 在构造函数中sem_init()，在析构函数中sem_destroy()，通过wait()获取，notify()释放。 class Semaphere { public: Semaphere(uint32_t count = 0); ~Semaphere(); void wait(); void notify(); private: Semaphere(const Semaphere&) = delete; Semaphere(const Semaphere&&) = delete; Semaphere& operator=(const Semaphere&) = delete; private: sem_t m_semaphere; }; 2.2.2 Mutex 互斥锁，基于pthread_mutex_t实现 2.2.3 RWMutex 读写锁，基于pthread_rwlock_t实现 2.2.4 Spinlock 自旋锁，基于pthread_spinlock_t实现 2.2.5 CASLock 原子锁，基于std::atomic_flag实现 2.2.6 ScopedLockImpl 锁的统一模版封装，对所有锁类统一使用，如果需要换锁，直接替换相应关键字即可。 3. 总结 在日志系统与配置系统使用互斥量是为了保证线程安全，因为日志系统写多读少所以使用Mutex，但有性能要求，所以使用的是Spinlock,在配置系统中是读多写少，所以使用的是读写锁RWmutex。速度大概在每秒25M左右。 在所有需要读取/更改数据的地方都要加锁。 "},"server/Fiber/":{"url":"server/Fiber/","title":"协程模块","keywords":"","body":"协程模块 基于ucontext_t实现非对称协程。也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。 1. ucontext_t 实现一个进程中的用户级线程（协程）切换。 // 上下文结构体定义 // 这个结构体是平台相关的，因为不同平台的寄存器不一样 // 下面列出的是所有平台都至少会包含的4个成员 typedef struct ucontext_t { // 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效 struct ucontext_t *uc_link; // 当前上下文的信号屏蔽掩码 sigset_t uc_sigmask; // 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效 stack_t uc_stack; // 平台相关的上下文具体内容，包含寄存器的值 mcontext_t uc_mcontext; ... } ucontext_t; // 获取当前的上下文 int getcontext(ucontext_t *ucp); // 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数 int setcontext(const ucontext_t *ucp); // 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数， // 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp->uc_stack中，这段内存空间将作为func函数运行时的栈空间， // 同时也可以指定ucp->uc_link，表示函数运行结束后恢复uc_link指向的上下文， // 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了 // makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行 void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...); // 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中， // 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数 // swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换 int swapcontext(ucontext_t *oucp, const ucontext_t *ucp); 2. 模块设计 使用非对称协程模型，也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束。 在对称协程中，子协程可以直接和子协程切换，也就是说每个协程不仅要运行自己的入口函数代码，还要负责选出下一个合适的协程进行切换，相当于每个协程都要充当调度器的角色，这样程序设计起来会比较麻烦，并且程序的控制流也会变得复杂和难以管理。而在非对称协程中，可以借助专门的调度器来负责调度协程，每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。 非对称协程的行为与函数类似，因为函数在运行结束后也总是会返回调用者。 虽然目前还没有涉及到协程调度，但这里其实可以将线程的主协程想像成线程的调度协程，每个子协程执行完了，都必须切回线程主协程，由主协程负责选出下一个要执行的子协程。如果子协程可以和子协程切换，那就相当于变相赋予了子协程调度的权利，这在非对称协程里是不允许的。 借助了线程局部变量的功能来实现协程模块。线程局部变量与全局变量类似，不同之处在于声明的线程局部变量在每个线程都独有一份，而全局变量是全部线程共享一份。 使用线程局部变量（C++11 thread_local变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。 对于每个线程的协程上下文，设计了两个线程局部变量来存储上下文信息（对应源码的t_fiber和t_thread_fiber），也就是说，一个线程在任何时候最多只能知道两个协程的上下文。又由于只使用swapcontext来做协程切换，那就意味着，这两个线程局部变量必须至少有一个是用来保存线程主协程的上下文的，如果这两个线程局部变量存储的都是子协程的上下文，那么不管怎么调用swapcontext，都没法恢复主协程的上下文，也就意味着程序最终无法回到主协程去执行，程序也就跑飞了。 如果将线程的局部变量设置成一个类似链表的数据结构，那理论上应该也可以实现对称协程，也就是子协程可以直接和子协程切换，但代码复杂度上肯定会增加不少，因为要考虑多线程和公平调度的问题。 非对称协程代码实现简单，并且在后面实现协程调度时可以做到公平调度，缺点是子协程只能和线程主协程切换，意味着子协程无法创建并运行新的子协程，并且在后面实现协程调度时，完成一次子协程调度需要额外多切换一次上下文。 3. 模块实现 3.1 协程状态 enum State { INIT, // 初始化状态 HOLD, // 暂停状态 EXEC, // 执行中状态 TERM, // 结束状态 READY, // 可执行状态 EXCEPT // 异常状态 }; 3.2 协程原语 对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。 3.3 协程类 3.3.1 Fiber 主要成员变量: uint64_t m_id = 0; // 协程id uint32_t m_stacksize = 0; // 协程运行栈大小 State m_state = INIT; // 协程状态 ucontext_t m_ctx; // 协程上下文 void* m_stack = nullptr; // 协程运行栈指针 std::function m_cb; // 协程运行函数 3.3.2 全局与线程局部变量 // 全局静态变量，用于生成协程id static std::atomic s_fiber_id{0}; // 全局静态变量，用于统计当前的协程数 static std::atomic s_fiber_count{0}; // 线程局部变量，当前线程正在运行的协程 static thread_local Fiber *t_fiber = nullptr; // 线程局部变量，当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行，智能指针形式 static thread_local Fiber::ptr t_thread_fiber = nullptr; t_fiber：保存当前正在运行的协程指针，必须时刻指向当前正在运行的协程对象。协程模块初始化时，t_fiber指向线程主协程对象。 t_thread_fiber：保存线程主协程指针，智能指针形式。协程模块初始化时，t_thread_fiber指向线程主协程对象。当子协程resume时，通过swapcontext将主协程的上下文保存到t_thread_fiber的ucontext_t成员中，同时激活子协程的ucontext_t上下文。当子协程yield时，从t_thread_fiber中取得主协程的上下文并恢复运行。 3.3.3 GetThis() 如果存在协程，则返回对象，否则先创建主协程，让t_fiber指向主协程并返回。 缺点：在使用协程之前必须显式调用一次GetThis()。 Fiber::ptr Fiber::GetThis() { if (t_fiber) { return t_fiber -> shared_from_this(); } Fiber::ptr main_fiber(new Fiber); JUJIMEIZUO_ASSERT(t_fiber == main_fiber.get()); t_threadFiber = main_fiber; return t_fiber -> shared_from_this(); } 3.3.4 MainFunc() 协程入口函数 封装用户的协程入口函数，在函数结束时自动执行yield操作。 void Fiber::MainFunc() { Fiber::ptr cur = GetThis(); // GetThis()的shared_from_this()方法让引用计数加1 JUJIMEIZUO_ASSERT(cur); cur->m_cb(); // 这里真正执行协程的入口函数 cur->m_cb = nullptr; cur->m_state = TERM; auto raw_ptr = cur.get(); // 手动让t_fiber的引用计数减1 cur.reset(); // 重复利用已结束的协程，复用其栈空间，创建新协程 raw_ptr->swapOut(); // 协程结束时自动yield，以回到主协程 } 总结 协程id：通过全局静态变量s_fiber_id的自增来生成协程id，每创建一个新协程，s_fiber_id自增1，并作为新协程的id（实际是先取值，再自增1）。 主协程创建：线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有ucontext_t上下文，但没有入口函数，也没有分配栈空间。 协程切换：子协程的resume操作一定是在主协程里执行的，主协程的resume操作一定是在子协程里执行的。 "},"server/Scheduler/":{"url":"server/Scheduler/","title":"协程调度模块","keywords":"","body":"线程调度模块 实现了一个N-M的协程调度器，N个线程运行M个协程，协程可以在线程之间进行切换，也可以绑定到指定线程运行。 实现协程调度之后，可以解决协程模块中子协程不能运行另一个子协程的缺陷，子协程可以通过向调度器添加调度任务的方式来运行另一个子协程。 1. 模块设计 调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。调度线程可以包含caller线程。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。 协程调度模块支持多线程，支持使用caller线程进行调度，支持添加函数或协程作为调度对象，并且支持将函数或协程绑定到一个具体的线程上执行。 首先是协程调度器的初始化。协程调度器在初始化时支持传入线程数和一个布尔型的use_caller参数，表示是否使用caller线程。在使用caller线程的情况下，线程数自动减一，并且调度器内部会初始化一个属于caller线程的调度协程并保存起来（比如，在main函数中创建的调度器，如果use_caller为true，那调度器会初始化一个属于main函数线程的调度协程）。 调度器创建好后，即可调用调度器的schedule方法向调度器添加调度任务，但此时调度器并不会立刻执行这些任务，而是将它们保存到内部的一个任务队列中。 接下来是调用start方法启动调度。start方法调用后会创建调度线程池，线程数量由初始化时的线程数和use_caller确定。调度线程一旦创建，就会立刻从任务队列里取任务执行。比较特殊的一点是，如果初始化时指定线程数为1且use_caller为true，那么start方法什么也不做，因为不需要创建新线程用于调度。并且，由于没有创建新的调度线程，那只能由caller线程的调度协程来负责调度协程，而caller线程的调度协程的执行时机与start方法并不在同一个地方。 接下来是调度协程，对应run方法。调度协程负责从调度器的任务队列中取任务执行。取出的任务即子协程，这里调度协程和子协程的切换模型即为前一章介绍的非对称模型，每个子协程执行完后都必须返回调度协程，由调度协程重新从任务队列中取新的协程并执行。如果任务队列空了，那么调度协程会切换到一个idle协程，这个idle协程什么也不做，等有新任务进来时，idle协程才会退出并回到调度协程，重新开始下一轮调度。 在非caller线程里，调度协程就是调度线程的主线程，但在caller线程里，调度协程并不是caller线程的主协程，而是相当于caller线程的子协程，这在协程切换时会有大麻烦（这点是协程调度模块最难理解的地方），如何处理这个问题将在下面的章节专门进行讨论。 接下来是添加调度任务，对应schedule方法，这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次tickle方法以通知各调度线程的调度协程有新任务来了。 在执行调度任务时，还可以通过调度器的GetThis()方法获取到当前调度器，再通过schedule方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能。 接下来是调度器的停止。调度器的停止行为要分两种情况讨论，首先是use_caller为false的情况，这种情况下，由于没有使用caller线程进行调度，那么只需要简单地等各个调度线程的调度协程退出就行了。如果use_caller为true，表示caller线程也要参于调度，这时，调度器初始化时记录的属于caller线程的调度协程就要起作用了，在调度器停止前，应该让这个caller线程的调度协程也运行一次，让caller线程完成调度工作后再退出。如果调度器只使用了caller线程进行调度，那么所有的调度任务要在调度器停止时才会被调度。 2. 调度器切换 这里分两种典型情况来讨论一下调度协程的切换情况，其他情况可以看成以下两种情况的组合，原理是一样的。 线程数为1，且use_caller为true，对应只使用main函数线程进行协程调度的情况。 线程数为1，且use_caller为false，对应额外创建一个线程进行协程调度、main函数线程不参与调度的情况。 这里先说情况2。情况2比较好理解，因为有单独的线程用于协程调度，那只需要让新线程的入口函数作为调度协程，从任务队列里取任务执行就行了，main函数与调度协程完全不相关，main函数只需要向调度器添加任务，然后在适当的时机停止调度器即可。当调度器停止时，main函数要等待调度线程结束后再退出，参考下面的图示： 情况1则比较复杂，因为没有额外的线程进行协程调度，那只能用main函数所在的线程来进行调度，而梳理一下main函数线程要运行的协程，会发现有以下三类协程： main函数对应的主协程 调度协程 待调度的任务协程 在main函数线程里这三类协程运行的顺序是这样的： main函数主协程运行，创建调度器 仍然是main函数主协程运行，向调度器添加一些调度任务 开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有的任务 每次执行一个任务，调度协程都要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要再切回调度协程，继续下一个任务的调度 所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，以保证程序能顺利结束。 上面的过程也可以总结为：main函数先攒下一波协程，然后切到调度协程里去执行，等把这些协程都消耗完后，再从调度协程切回来，像下面这样： 3. 模块实现 3.1 FiberAndThread 调度任务 可以是协程，可以是函数，封装成一种类型，可指定调度线程。 3.2 变量 3.2.1 Scheduler成员变量 MutexType m_mutex; // Mutex std::vector m_threads; // 线程池 std::list m_fibers; // 待执行的协程队列 Fiber::ptr m_rootFiber; // use_caller为true时有效, 调度协程 std::string m_name; // 协程调度器名称 std::vector m_threadIds; // 协程下的线程id数组 size_t m_threadCount = 0; // 线程数量 std::atomic m_activeThreadCount = {0}; // 工作线程数量 std::atomic m_idleThreadCount = {0}; // 空闲线程数量 bool m_stopping = true; // 是否正在停止 bool m_autoStop = false; // 是否自动停止 int m_rootThread = 0; // 主线程id(use_caller) 3.2.2 全局与线程局部变量 // 当前线程的调度器，同一个调度器下的所有线程指同同一个调度器实例 static thread_local Scheduler *t_scheduler = nullptr; // 当前线程的调度协程，每个线程都独有一份，包括caller线程 static thread_local Fiber *t_scheduler_fiber = nullptr; t_scheduler_fiber保存当前线程的调度协程，加上Fiber模块的t_fiber和t_thread_fiber，每个线程总共可以记录三个协程的上下文信息。 3.3 调度器的构造 在user_caller为true的情况下，初始化caller线程的调度协程，caller线程的调度协程不会被调度器调度，而且，caller线程的调度协程停止时，应该返回caller线程的主协程。 3.4 调度器的启动 初始化调度线程池，如果只使用caller线程进行调度，那这个方法啥也不做。 3.5 判断调度器是否停止 只有当所有的任务都被执行完了，调度器才可以停止。 3.6 调度器的运行 内部有一个while(true)循环，不停地从任务队列取任务并执行，由于Fiber类改造过，每个被调度器执行的协程在结束时都会回到调度协程，所以这里不用担心跑飞问题，当任务队列为空时，代码会进idle协程，但idle协程啥也不做直接就yield了，状态还是READY状态，所以这里其实就是个忙等待，CPU占用率爆炸，只有当调度器检测到停止标志时，idle协程才会真正结束，调度协程也会检测到idle协程状态为TERM，并且随之退出整个调度协程。这里还可以看出一点，对于一个任务协程，只要其从resume中返回了，那不管它的状态是TERM还是READY，调度器都不会自动将其再次加入调度，因为一个成熟的协程是要学会自我管理的。 3.7 调度器的停止 在使用了caller线程的情况下，调度器依赖stop方法来执行caller线程的调度协程，如果调度器只使用了caller线程来调度，那调度器真正开始执行调度的位置就是这个stop方法。 停止调度器的策略： 设置m_stopping标志，该标志表示正在停止 检测是否使用了caller线程进行调度，如果使用了caller线程进行调度，那要保证stop方法是由caller线程发起的 通知其他调度线程的调度协程退出调度 通知当前线程的调度协程退出调度 如果使用了caller线程进行调度，那执行一次caller线程的调度协程（只使用caller线程时的协程调度全仰仗这个操作） 等caller线程的调度协程返回 等所有调度线程结束 4. 总结 协程调度模块因为存任务队列空闲时调度线程忙等待的问题，所以实际上并不实用，真正实用的是后面基于Scheduler实现的IOManager。由于任务队列的任务是按顺序执行的，如果有一个任务占用了比较长时间，那其他任务的执行会受到影响，如果任务执行的是像while(1)这样的循环，那线程数不够时，后面的任务都不会得到执行。另外，当前还没有实现hook功能，像sleep和等待IO就绪这样的操作也会阻塞协程调度。 "},"server/IOManager/":{"url":"server/IOManager/","title":"IO协程调度模块","keywords":"","body":"IO协程调度模块 IO协程调度解决了调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。 1. 模块设计 IO协程调度模块基于epoll实现，只支持Linux平台。对每个fd，支持两类事件，一类是可读事件，对应EPOLLIN，一类是可写事件，对应EPOLLOUT，事件枚举值直接继承自epoll。 当然epoll本身除了支持了EPOLLIN和EPOLLOUT两类事件外，还支持其他事件，比如EPOLLRDHUP, EPOLLERR, EPOLLHUP等，对于这些事件，做法是将其进行归类，分别对应到EPOLLIN和EPOLLOUT中，也就是所有的事件都可以表示为可读或可写事件，甚至有的事件还可以同时表示可读及可写事件，比如EPOLLERR事件发生时，fd将同时触发可读和可写事件。 对于IO协程调度来说，每次调度都包含一个三元组信息，分别是描述符-事件类型（可读或可写）-回调函数，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于epoll_wait，回调函数用于协程调度。这个三元组信息在源码上通过FdContext结构体来存储，在执行epoll_wait时通过epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。 IO协程调度器在idle时会epoll_wait所有注册的fd，如果有fd满足条件，epoll_wait返回，从私有数据中拿到fd的上下文信息，并且执行其中的回调函数。（实际是idle协程只负责收集所有已触发的fd的回调函数并将其加入调度器的任务队列，真正的执行时机是idle协程退出后，调度器在下一轮调度时执行） 与协程调度器不一样的是，IO协程调度器支持取消事件。取消事件表示不关心某个fd的某个事件了，如果某个fd的可读或可写事件都被取消了，那这个fd会从调度器的epoll_wait中删除。 2. 模块实现 2.1 IOManager IO协程调度器 class IOManager : public Scheduler { public: typedef std::shared_ptr ptr; typedef RWMutex RWMutexType; ... } 2.2 读写事件 IO事件，只关心socket fd的读和写事件，其他epoll事件会归类到这两类事件中 enum Event { /// 无事件 NONE = 0x0, /// 读事件(EPOLLIN) READ = 0x1, /// 写事件(EPOLLOUT) WRITE = 0x4, }; 2.3 三元组 描述符-事件类型-回调函数三元组的定义，这个三元组也称为fd上下文，使用结构体FdContext来表示。由于fd有可读和可写两种事件，每种事件的回调函数也可以不一样，所以每个fd都需要保存两个事件类型-回调函数组合。 struct FdContext { typedef Mutex MutexType; struct EventContext { Scheduler *scheduler = nullptr; Fiber::ptr fiber; std::function cb; }; EventContext &getEventContext(Event event); void resetEventContext(EventContext &ctx); void triggerEvent(Event event); EventContext read; EventContext write; int fd = 0; Event events = NONE; MutexType mutex; 2.4 事件处理 注册事件回调addEvent 删除事件回调delEvent 取消事件回调cancelEvent 以及取消全部事件cancelAll 3. 总结 IO协程调度模块可分为两部分，第一部分是对协程调度器的改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有的功能不变。第二部分是基于epoll实现IO事件的添加、删除、调度、取消等功能。 IO协程调度关注的是FdContext信息，也就是描述符-事件-回调函数三元组，IOManager需要保存所有关注的三元组，并且在epoll_wait检测到描述符事件就绪时执行对应的回调函数。 FdContext的寻址问题，直接使用fd的值作为FdContext数组的下标，这样可以快速找到一个fd对应的FdContext。由于关闭的fd会被重复利用，所以这里也不用担心FdContext数组膨胀太快，或是利用率低的问题。 IO协程调度器的退出，不但所有协程要完成调度，所有IO事件也要完成调度。 "},"server/Timer/":{"url":"server/Timer/","title":"定时器模块","keywords":"","body":"定时器模块 基于epoll超时实现定时器功能，精度毫秒级，支持在指定超时时间结束之后执行回调函数。通过定时器可以实现给服务器注册定时事件，这是服务器上经常要处理的一类事件，比如3秒后关闭一个连接，或是定期检测一个客户端的连接状态。 1. 模块设计 定时器采用最小堆设计，所有定时器根据绝对的超时时间点进行排序，每次取出离当前时间最近的一个超时时间点，计算出超时需要等待的时间，然后等待超时。超时时间到后，获取当前的绝对时间点，然后把最小堆里超时时间点小于这个时间点的定时器都收集起来，执行它们的回调函数。 注意，在注册定时事件时，一般提供的是相对时间，比如相对当前时间3秒后执行。会根据传入的相对时间和当前的绝对时间计算出定时器超时时的绝对时间点，然后根据这个绝对时间点对定时器进行最小堆排序。因为依赖的是系统绝对时间，所以需要考虑校时因素。 定时器的超时等待基于epoll_wait，精度只支持毫秒级，因为epoll_wait的超时精度也只有毫秒级。 关于定时器和IO协程调度器的整合。IO协程调度器的idle协程会在调度器空闲时阻塞在epoll_wait上，等待IO事件发生。在之前的代码里，epoll_wait具有固定的超时时间，这个值是5秒钟。加入定时器功能后，epoll_wait的超时时间改用当前定时器的最小超时时间来代替。epoll_wait返回后，根据当前的绝对时间把已超时的所有定时器收集起来，执行它们的回调函数。 由于epoll_wait的返回并不一定是超时引起的，也有可能是IO事件唤醒的，所以在epoll_wait返回后不能想当然地假设定时器已经超时了，而是要再判断一下定时器有没有超时，这时绝对时间的好处就体现出来了，通过比较当前的绝对时间和定时器的绝对超时时间，就可以确定一个定时器到底有没有超时。 2. 模块实现 2.1 Timer 定时器 class TimerManager; class Timer : public std::enable_shared_from_this { friend class TimerManager; public: typedef std::shared_ptr ptr; bool cancel(); bool refresh(); bool reset(uint64_t ms, bool from_now); private: Timer(uint64_t ms, std::function cb, bool recurring, TimerManager* manager); Timer(uint64_t next); private: bool m_recurring = false; uint64_t m_ms = 0; uint64_t m_next = 0; std::function m_cb; TimerManager* m_manager = nullptr; private: struct Comparator { bool operator()(const Timer::ptr& lhs, const Timer::ptr& rhs) const; }; }; 2.2 TimerManager 定时器管理器 class TimerManager { friend class Timer; public: typedef RWMutex RWMutexType; TimerManager(); virtual ~TimerManager(); Timer::ptr addTimer(uint64_t ms, std::function cb ,bool recurring = false); Timer::ptr addConditionTimer(uint64_t ms, std::function cb ,std::weak_ptr weak_cond ,bool recurring = false); uint64_t getNextTimer(); void listExpiredCb(std::vector >& cbs); bool hasTimer(); protected: virtual void onTimerInsertedAtFront() = 0; void addTimer(Timer::ptr val, RWMutexType::WriteLock& lock); private: bool detectClockRollover(uint64_t now_ms); private: RWMutexType m_mutex; std::set m_timers; bool m_tickled = false; uint64_t m_previouseTime = 0; }; IOManager也需要继承TimerManager获得一个定时器管理模块。 class IOManager : public Scheduler, public TimerManager {}; 3. 总结 创建定时器时只传入了相对超时时间，内部要先进行转换，根据当前时间把相对时间转化成绝对时间。 支持创建条件定时器，也就是在创建定时器时绑定一个变量，在定时器触发时判断一下该变量是否仍然有效，如果变量无效，那就取消触发。 "},"server/Hook/":{"url":"server/Hook/","title":"Hook模块","keywords":"","body":"Hook模块 hook系统底层和socket相关的API，socket IO相关的API，以及sleep系列的API。hook的开启控制是线程粒度的，可以自由选择。通过hook模块，可以使一些不具异步功能的API，展现出异步的性。 1. 模块设计 hook功能以线程为单位，可自由设置当前线程是否使用hook。默认情况下，协程调度器的调度线程会开启hook，而其他线程则不会开启。 以下函数进行了hook，并且只对socket fd进行了hook，如果操作的不是socket fd，那会直接调用系统原本的API，而不是hook之后的API： sleep usleep nanosleep socket connect accept read readv recv recvfrom recvmsg write writev send sendto sendmsg close fcntl ioctl getsockopt setsockopt 增加了一个 connect_with_timeout 接口用于实现带超时的connect。 为了管理所有的socket fd，设计了一个FdManager类来记录所有分配过的fd的上下文，这是一个单例类，每个socket fd上下文记录了当前fd的读写超时，是否设置非阻塞等信息。 关于hook模块和IO协程调度的整合。一共有三类接口需要hook，如下： sleep延时系列接口，包括sleep/usleep/nanosleep。对于这些接口的hook，只需要给IO协程调度器注册一个定时事件，在定时事件触发后再继续执行当前协程即可。当前协程在注册完定时事件后即可yield让出执行权。 socket IO系列接口，包括read/write/recv/send...等，connect及accept也可以归到这类接口中。这类接口的hook首先需要判断操作的fd是否是socket fd，以及用户是否显式地对该fd设置过非阻塞模式，如果不是socket fd或是用户显式设置过非阻塞模式，那么就不需要hook了，直接调用操作系统的IO接口即可。如果需要hook，那么首先在IO协程调度器上注册对应的读写事件，等事件发生后再继续执行当前协程。当前协程在注册完IO事件即可yield让出执行权。 socket/fcntl/ioctl/close等接口，这类接口主要处理的是边缘情况，比如分配fd上下文，处理超时及用户显式设置非阻塞问题。 2. 模块实现 2.1 FdCtx 文件句柄上下文类，管理文件句柄类型（是否socket，是否阻塞，是否关闭，读/写超时时间） FdCtx类在用户态记录了fd的读写超时和非阻塞信息，其中非阻塞包括用户显式设置的非阻塞和hook内部设置的非阻塞，区分这两种非阻塞可以有效应对用户对fd设置/获取NONBLOCK模式的情形。 class FdCtx : public std::enable_shared_from_this { public: typedef std::shared_ptr ptr; FdCtx(int fd); ~FdCtx(); .... private: bool m_isInit: 1; bool m_isSocket: 1; bool m_sysNonblock: 1; bool m_userNonblock: 1; bool m_isClosed: 1; int m_fd; uint64_t m_recvTimeout; uint64_t m_sendTimeout; }; 2.2 FdManager 文件句柄管理类 FdManager类对FdCtx的寻址采用了和IOManager中对FdContext的寻址一样的寻址方式，直接用fd作为数组下标进行寻址。 class FdManager { public: typedef RWMutex RWMutexType; FdManager(); FdCtx::ptr get(int fd, bool auto_create = false); void del(int fd); private: RWMutexType m_mutex; std::vector m_datas; }; 2.3 hook 首先定义线程局部变量t_hook_enable，用于表示当前线程是否启用hook，使用线程局部变量表示hook模块是线程粒度的，各个线程可单独启用或关闭hook。然后是获取各个被hook的接口的原始地址， 这里要借助dlsym来获取。 具体通过宏来简化代码： #define HOOK_FUN(XX) \\ XX(sleep) \\ XX(usleep) \\ XX(nanosleep) \\ XX(socket) \\ XX(connect) \\ XX(accept) \\ XX(read) \\ XX(readv) \\ XX(recv) \\ XX(recvfrom) \\ XX(recvmsg) \\ XX(write) \\ XX(writev) \\ XX(send) \\ XX(sendto) \\ XX(sendmsg) \\ XX(close) \\ XX(fcntl) \\ XX(ioctl) \\ XX(getsockopt) \\ XX(setsockopt) extern \"C\" { #define XX(name) name ## _fun name ## _f = nullptr; HOOK_FUN(XX); #undef XX } void hook_init() { static bool is_inited = false; if(is_inited) { return; } #define XX(name) name ## _f = (name ## _fun)dlsym(RTLD_NEXT, #name); HOOK_FUN(XX); #undef XX } hook_init() 放在一个静态对象的构造函数中调用，这表示在main函数运行之前就会获取各个符号的地址并保存在全局变量中。 3. 总结 由于定时器模块只支持毫秒级定时，所以被hook后的nanosleep()实际精度只能达到毫秒级，而不是纳秒级。 非调度线程不支持启用hook。 "},"server/Address/":{"url":"server/Address/","title":"网络地址模块","keywords":"","body":"网络地址模块 提供网络地址相关的类，支持与网络地址相关的操作。 1. 模块设计 所有网络地址的方法，包括网络地址查询及网卡地址查询功能等等。包括IPv4、IPv6、Unix、Unknown地址类，操作各成员的网络地址和端口，以及获取子码掩码等操作。 Linux使用Berkeley套接字接口进行网络编程，这套接口是事实上的标准网络套接字编程接口，在基本所有的系统上都支持。Berkeley套接字接口提供了一系列用于网络编程的通用API，通过这些API可以实现跨主机之间网络通信，或是在本机上通过Unix域套接字进行进程间通信。 所有的套接字API都是以指针形式接收sockaddr参数，并且额外需要一个地址长度参数，这可以保证当sockaddr本身不足以容纳一个具体的地址时，可以通过指针取到全部的内容。比如上面的地址内容占14字节，这并不足以容纳一个128位16字节的IPv6地址。但当以指针形式传入时，完全可以通过指针取到适合IPv6的长度。 除sockaddr外，套接字接口还定义了一系列具体的网络地址结构，比如sockaddr_in表示IPv4地址，sockaddr_in6表示IPv6地址，sockaddr_un表示Unix域套接字地址。 2. 模块实现 2.1 Address 网络地址类的基类，同时是一个抽象类，对应sockaddr，表示通用网络地址。Address类还提供了地址解析与本机网卡地址查询的功能，地址解析功能可以实现域名解析，网卡地址查询可以获取本机指定网卡的IP地址。 class Address { public: typedef std::shared_ptr ptr; static Address::ptr Create(const sockaddr *addr, socklen_t addrlen); static bool Lookup(std::vector &result, const std::string &host, int family = AF_INET, int type = 0, int protocol = 0); static Address::ptr LookupAny(const std::string &host, int family = AF_INET, int type = 0, int protocol = 0); static std::shared_ptr LookupAnyIPAddress(const std::string &host, int family = AF_INET, int type = 0, int protocol = 0); static bool GetInterfaceAddresses(std::multimap> &result, int family = AF_INET); static bool GetInterfaceAddresses(std::vector> &result, const std::string &iface, int family = AF_INET); virtual ~Address() {} int getFamily() const; virtual const sockaddr *getAddr() const = 0; virtual sockaddr *getAddr() = 0; virtual socklen_t getAddrLen() const = 0; virtual std::ostream &insert(std::ostream &os) const = 0; std::string toString() const; bool operator 2.2 IPAdress 继承自Address类，表示一个IP地址，同样是一个抽象类，因为IP地址包含IPv4地址和IPv6地址。IPAddress类提供了IP地址相关的端口和掩码、网段地址、网络地址操作，无论是IPv4还是IPv6都支持这些操作，但这些方法都是抽象方法，需要由继承类来实现。 2.3 IPv4Address 继承自IPAddress类，表示一个IPv4地址，到这一步，IPv4Address就是一个实体类了，它包含一个sockaddr_in类型的成员，并且提供具体的端口设置/获取，掩码、网段、网络地址设置/获取操作。 2.4 IPv6Address 继承自IPAddress类，表示一个IPv6地址，也是一个实体类，实现思路和IPv4Address一致。 2.5 UnixAddress 继承自Address类，表示一个Unix域套接字地址，是一个实体类，可以用于实例化对象。UnixAddress类包含一个sockaddr_un对象以及一个路径字符串长度。 2.6 UnknownAddress 继承自Address类，包含一个sockaddr成员，表示未知的地址类型。 3. 总结 整个网络地址模块可以处理任何形式的地址，包括IPv4、IPv6、Unix和未知的Unknown地址，没有针对每种类型的地址都制定一套对应的API接口，而是拟定了一个通用的套接字地址结构sockaddr，用于表示任意类型的地址，所以的套接字API在传入地址参数时都只需要传入sockaddr类型，保证接口的通用性。还有一系列表示具体的网络地址的结构，这些具体的网络地址结构用于用户赋值，但在使用时，都要转化成sockaddr的形式。 "},"server/Socket/":{"url":"server/Socket/","title":"Socket模块","keywords":"","body":"Socket模块 套接字类，表示一个套接字对象。 1. 模块设计 对于套接字类，需要关注以下属性： 文件描述符 地址类型（AF_INET, AF_INET6等） 套接字类型（SOCK_STREAM, SOCK_DGRAM等） 协议类型（这项其实可以忽略） 是否连接（针对TCP套接字，如果是UDP套接字，则默认已连接） 本地地址和对端的地址 套接字类应提供以下方法： 创建各种类型的套接字对象的方法（TCP套接字，UDP套接字，Unix域套接字） 设置套接字选项，比如超时参数 bind/connect/listen方法，实现绑定地址、发起连接、发起监听功能 accept方法，返回连入的套接字对象 发送、接收数据的方法 获取本地地址、远端地址的方法 获取套接字类型、地址类型、协议类型的方法 取消套接字读、写的方法 2. 模块实现 2.1 Socket 套接字类，继承enable_shared_from_this，且无法拷贝赋值 class Socket : public std::enable_shared_from_this, Noncopyable { public: typedef std::shared_ptr ptr; typedef std::weak_ptr weak_ptr; /** * @brief Socket类型 */ enum Type { /// TCP类型 TCP = SOCK_STREAM, /// UDP类型 UDP = SOCK_DGRAM }; /** * @brief Socket协议簇 */ enum Family { /// IPv4 socket IPv4 = AF_INET, /// IPv6 socket IPv6 = AF_INET6, /// Unix socket UNIX = AF_UNIX, }; ... protected: int m_sock; int m_family; int m_type; int m_protocol; bool m_isConnected; Address::ptr m_localAddress; Address::ptr m_remoteAddress; }; 3. 总结 一个完整的套接字类，创建包括TCP套接字、UDP套接字、Unix域套接字等等，还有各种套接字选项参数，实现绑定地址、发起连接、发起监听功能，可以获取本地和远端地址、套接字类型、地址类型、协议类型等等。 "},"server/ByteArray/":{"url":"server/ByteArray/","title":"ByteArray序列化模块","keywords":"","body":"ByteArray序列化模块 ByteArray二进制序列化模块，提供对二进制数据的常用操作。读写入基础类型int8_t,int16_t,int32_t,int64_t等，支持Varint,std::string的读写支持,支持字节序转化,支持序列化到文件，以及从文件反序列化等功能。 1. 模块设计 ByteArray的底层存储是固定大小的块，以链表形式组织。每次写入数据时，将数据写入到链表最后一个块中，如果最后一个块不足以容纳数据，则分配一个新的块并添加到链表结尾，再写入数据。ByteArray会记录当前的操作位置，每次写入数据时，该操作位置按写入大小往后偏移，如果要读取数据，则必须调用setPosition重新设置当前的操作位置。 ByteArray支持基础类型的序列化与反序列化功能，并且支持将序列化的结果写入文件，以及从文件中读取内容进行反序列化。ByteArray支持以下类型的序列化与反序列化： 固定长度的有符号/无符号8位、16位、32位、64位整数 不固定长度的有符号/无符号32位、64位整数 float、double类型 字符串，包含字符串长度，长度范围支持16位、32位、64位。 字符串，不包含长度。 以上所有的类型都支持读写。 ByteArray还支持设置序列化时的大小端顺序。 2. 模块实现 2.1 ByteArray 二进制序列化类 二进制数组,提供基础类型的序列化,反序列化功能。 class ByteArray { public: typedef std::shared_ptr ptr; struct Node { Node(size_t s); Node(); ~Node(); char* ptr; Node* next; size_t size; }; ... private: size_t m_baseSize; size_t m_position; size_t m_capacity; size_t m_size; int8_t m_endian; Node* m_root; Node* m_cur; }; 2.2 endian 8/4/2字节类型的字节序转化 template typename std::enable_if::type byteswap(T value) { return (T)bswap_XX((uintXX_t)value); } 3. 总结 ByteArray在序列化不固定长度的有符号/无符号32位、64位整数时使用了zigzag算法。 ByteArray在序列化字符串时使用TLV中的Length和Value。 可以自适应在大端机器和小端机器执行byteswap。 "},"server/Stream/":{"url":"server/Stream/","title":"字节流序列化模块","keywords":"","body":"字节流模块 封装流式的统一接口。将文件，socket封装成统一的接口。使用的时候，采用统一的风格操作。基于统一的风格，可以提供更灵活的扩展。 1. 模块设计 所有的流结构都继承自抽象类Stream，Stream类规定了一个流必须具备read/write接口和readFixSize/writeFixSize接口，继承自Stream的类必须实现这些接口。 read：读数据，接收内存或ByteArray write：写数据，接收内存或ByteArray readFixSize 写固定长度的数据，接收内存或ByteArray writeFixSize 读固定长度的数据，接收内存或ByteArray 2. 模块实现 2.1 Stream 流结构 class Stream { public: typedef std::shared_ptr ptr; virtual ~Stream() {} virtual int read(void* buffer, size_t length) = 0; virtual int read(ByteArray::ptr ba, size_t length) = 0; virtual int readFixSize(void* buffer, size_t length); virtual int readFixSize(ByteArray::ptr ba, size_t length); virtual int write(const void* buffer, size_t length) = 0; virtual int write(ByteArray::ptr ba, size_t length) = 0; virtual int writeFixSize(const void* buffer, size_t length); virtual int writeFixSize(ByteArray::ptr ba, size_t length); virtual void close() = 0; }; 2.2 SocketStream Socket流 class SocketStream : public Stream { public: typedef std::shared_ptr ptr; ... protected: /// Socket类 Socket::ptr m_socket; /// 是否主控 bool m_owner; }; 3. 总结 SocketStream类将套接字封装成流结构，以支持Stream接口规范，除此外，SocketStream还支持套接字关闭操作以及获取本地/远端地址的操作。 "},"server/TcpServer/":{"url":"server/TcpServer/","title":"TcpServer模块","keywords":"","body":"TcpServer模块 基于Socket类，封装了一个通用的TcpServer的服务器类，提供简单的API，使用便捷。 1. 模块设计 TcpServer类支持同时绑定多个地址进行监听，只需要在绑定时传入地址数组即可。TcpServer还可以分别指定接收客户端和处理客户端的协程调度器。 比较好的TcpServer可以快速绑定一个或多个地址，启动服务，监听端口，accept连接，处理socket连接等功能。具体业务功能更的服务器实现，只需要继承该类就可以快速实现. 2. 模块实现 2.1 TcpServer TCP服务器封装 class TcpServer : public std::enable_shared_from_this , Noncopyable { public: typedef std::shared_ptr ptr; ... protected: /// 监听Socket数组 std::vector m_socks; /// 新连接的Socket工作的调度器 IOManager* m_ioWorker; /// 服务器Socket接收连接的调度器 IOManager* m_acceptWorker; /// 接收超时时间(毫秒) uint64_t m_recvTimeout; /// 服务器名称 std::string m_name; /// 服务器类型 std::string m_type; /// 服务是否停止 bool m_isStop; }; 3. Usage 通过自定义TcpServer，并且重载HandleClient方法即可。 class MyTcpServer : public jujimeizuo::TcpServer { protected: virtual void handleClient(jujimeizuo::Socket::ptr client) override; }; void MyTcpServer::handleClient(jujimeizuo::Socket::ptr client) { JUJIMEIZUO_LOG_INFO(g_logger) toString(); static std::string buf; buf.resize(4096); client->recv(&buf[0], buf.length()); // 这里有读超时，由tcp_server.read_timeout配置项进行配置，默认120秒 JUJIMEIZUO_LOG_INFO(g_logger) close(); } 4. 总结 TcpServer类采用了Template Pattern设计模式，它的HandleClient是交由继承类来实现的。使用TcpServer时，必须从TcpServer派生一个新类，并重新实现子类的handleClient操作。 "}}